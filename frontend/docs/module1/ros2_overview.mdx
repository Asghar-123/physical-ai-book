---
sidebar_position: 1
title: ROS 2 Overview
---

# ROS 2 Overview: The Robotic Nervous System

The Robot Operating System (ROS) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robotic platforms. ROS 2 is the latest iteration, designed to address the limitations of ROS 1, particularly concerning multi-robot systems, real-time control, and embedded systems.

## Key Concepts in ROS 2

ROS 2 organizes robot applications into a graph of decentralized processing nodes. Each node is responsible for a specific task, such as reading sensor data, controlling motors, or performing navigation algorithms. These nodes communicate with each other using various mechanisms.

### Nodes

A **node** is an executable process that performs computations. In a typical robot system, you might have nodes for:
- Reading data from a LiDAR sensor
- Processing camera images for object detection
- Calculating robot kinematics
- Sending commands to motor controllers

Nodes are designed to be modular and independent, allowing for easy development, testing, and debugging.

### Topics

**Topics** are the most common way for nodes to communicate. They implement a publish/subscribe messaging model.
- A node **publishes** messages to a topic.
- Other nodes **subscribe** to that topic to receive the messages.

This asynchronous communication pattern is ideal for continuous data streams like sensor readings, motor states, or video feeds.

### Services

**Services** are a request/reply communication mechanism. They are used when a node needs to send a request to another node and wait for a response.
- A client node **sends a request** to a service.
- A server node **receives the request**, performs a computation, and **sends a response** back to the client.

Services are suitable for functionalities that require a direct response, such as triggering a specific action (e.g., "take a picture") or querying current robot status (e.g., "get current position").

### Actions

**Actions** provide a long-running goal-oriented communication pattern, building on topics and services. They are designed for tasks that might take a significant amount of time to complete and require periodic feedback (e.g., "go to a specific location").
- A client node **sends a goal** to an action server.
- The action server **provides continuous feedback** as it works towards the goal.
- The action server eventually **sends a result** upon completion.
- The client can also **send a cancel request** to stop the action in progress.

Actions are particularly useful for navigation, manipulation, or other complex behaviors where monitoring progress and potential cancellation are important.

## ROS 2 vs. ROS 1

ROS 2 was re-architected to address several limitations of ROS 1:
- **DDS (Data Distribution Service):** ROS 2 leverages DDS as its communication layer, providing features like quality of service (QoS) policies, improved reliability, and support for real-time systems. ROS 1 used its own custom TCP/IP-based communication.
- **Multi-robot support:** DDS enables easier discovery and communication across multiple robots without a central master.
- **Real-time capabilities:** Better support for real-time operating systems (RTOS) and deterministic execution.
- **Embedded systems:** More suitable for resource-constrained platforms.
- **Security:** Enhanced security features including authentication, encryption, and access control.

## Conclusion

Understanding nodes, topics, services, and actions is fundamental to developing applications with ROS 2. These communication primitives allow you to build modular, distributed, and robust robot systems, laying the groundwork for complex physical AI behaviors.
